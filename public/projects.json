[
  {
    "title": "seanpatrickmay.github.io",
    "slug": "seanpatrickmay-github-io",
    "emoji": "üåê",
    "period": "2024 ‚Äì Present",
    "startDate": "2024-01-01",
    "endDate": null,
    "updatedAt": "2025-12-01",
    "stack": [
      "Next.js",
      "React",
      "Tailwind CSS",
      "Garmin API",
      "Spotify API"
    ],
    "oneLiner": "Static portfolio with live activity dashboards and data hooks.",
    "cardDescription": "Static portfolio with live Garmin + Spotify dashboards and responsive card navigation.",
    "languages": [
      "JavaScript",
      "Python"
    ],
    "tags": [
      "Full-stack"
    ],
    "coolness": 89,
    "showcaseTag": "Full-stack",
    "showcaseTech": "Next.js",
    "proofPoints": [
      "Static export optimized for GitHub Pages",
      "Automated Garmin + Spotify refresh workflows",
      "Card-based navigation + responsive layouts"
    ],
    "overview": "This site is a static-exported Next.js portfolio that pulls in live Garmin and Spotify summaries via scheduled refresh scripts. The goal is a clean, fast UI that still feels alive with real data instead of placeholder widgets.",
    "whatIBuilt": [
      "Static-exported Next.js site with multiple content sections and responsive layout rules",
      "Data ingestion scripts + workflows for Garmin and Spotify JSON refreshes",
      "Reusable UI primitives for cards, pills, stacked sections, and scrolling lists"
    ],
    "howItWorks": [
      "Scheduled scripts fetch and write JSON into public/",
      "Pages read those JSON files client-side for lightweight dashboards",
      "The site is exported to static HTML and deployed via GitHub Pages"
    ],
    "results": [
      "Fast static site with dynamic-feeling dashboards",
      "Shareable /projects/ + /projects/<slug>/ routes compatible with static export"
    ],
    "nextSteps": [
      "Add lightweight per-project cover images and tighter case study templates",
      "Add Live links where appropriate"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "Static-exported Next.js site with stacked card navigation and responsive layouts.",
      "Live training + music dashboards powered by Garmin and Spotify refresh scripts.",
      "Long-form about section with auto-scrolling highlights and rich data visualizations."
    ],
    "links": [
      {
        "label": "Live Site",
        "href": "https://seanpatrickmay.github.io/",
        "kind": "live"
      },
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/seanpatrickmay.github.io",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "Life-Dashboard",
    "slug": "life-dashboard",
    "emoji": "üìä",
    "period": "Sep 2025 ‚Äì Dec 2025",
    "startDate": "2025-09-01",
    "endDate": "2025-12-01",
    "updatedAt": "2025-12-01",
    "stack": [
      "Python",
      "FastAPI",
      "PostgreSQL",
      "React",
      "TypeScript",
      "Vertex AI Gemini"
    ],
    "oneLiner": "Self-hosted wellness dashboard that turns Garmin biometrics + nutrition logs into agentic insights, readiness scoring, and actionable to-dos.",
    "featuredDescription": "Wellness dashboard turning Garmin + nutrition into actionable insights.",
    "cardDescription": "Wellness dashboard turning Garmin + nutrition into actionable insights.",
    "languages": [
      "Python",
      "TypeScript"
    ],
    "tags": [
      "Full-stack",
      "Agentic AI",
      "Data Engineering"
    ],
    "coolness": 100,
    "caseStudyRank": 1,
    "showcaseTag": "Agentic AI",
    "showcaseTech": "PostgreSQL",
    "proofPoints": [
      "Agentic nutrition workflow (recipes ‚Üí ingredients ‚Üí normalized facts)",
      "Garmin biometrics ingestion + trend features",
      "Turns insights into daily to-dos + journaling for follow-through",
      "Full-stack app: FastAPI + Postgres + React/TS"
    ],
    "overview": "Life-Dashboard is a self-hosted wellness app that combines Garmin biometrics with nutrition logging and agentic workflows. It keeps the data normalized, computes targets with uncertainty (95% CIs), and turns the result into simple, actionable to-dos instead of dashboards you ignore.",
    "whatIBuilt": [
      "Agentic nutrition workflow that parses natural language into ingredients + normalized nutrition facts",
      "Garmin data ingestion pipeline (HRV, RHR, sleep, training load) into Postgres",
      "React/TypeScript UI for trends, workflows, and structured to-dos"
    ],
    "howItWorks": [
      "Fetch Garmin biometrics on a schedule and store them in Postgres",
      "Preprocess 14-day time-series features for recovery/readiness signals",
      "Run agent workflows to translate logs into targets + next actions",
      "Render trends and recommendations in a React/TypeScript dashboard"
    ],
    "results": [
      "End-to-end pipeline from raw biometrics ‚Üí stored history ‚Üí actionable outputs",
      "Clean separation between ingestion, modeling, and UI"
    ],
    "nextSteps": [
      "Add tighter evals for agent outputs and recommendation quality",
      "Expand readiness scoring into training plan adjustments"
    ],
    "coverImage": {
      "src": "/projects/life-dashboard/life-dashboard-cover.png",
      "alt": "Life-Dashboard wellness dashboard overview"
    },
    "gallery": [],
    "bullets": [
      "Designed an agentic nutrition workflow that decomposes natural language into recipes + ingredients, uses web search to normalize/cache nutrition facts, and tracks intake vs personalized goals (with 95% CIs).",
      "Preprocessed 14-day time series of biometric data from the Garmin API to drive AI-curated recovery insights (sleep, HRV, RHR, training load).",
      "FastAPI backend ingests Garmin HRV, resting HR, sleep, and training load into PostgreSQL using async SQLAlchemy + Alembic migrations.",
      "React/TypeScript dashboard surfaces training trends, nutrition workflows, and intelligent to-dos with scheduled Garmin refresh flows."
    ],
    "links": [
      {
        "label": "Live Site",
        "href": "https://lifedashboard.tech",
        "kind": "live"
      },
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/Life-Dashboard",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "LecteurAide",
    "slug": "lecteuraide",
    "emoji": "üìö",
    "period": "Updated Oct 2025",
    "startDate": null,
    "endDate": null,
    "updatedAt": "2025-10-01",
    "stack": [
      "Python",
      "FastAPI",
      "Vertex AI Gemini",
      "Cloud Translation",
      "Next.js"
    ],
    "oneLiner": "French reading companion that segments scenes, translates sentences, and quizzes vocab.",
    "featuredDescription": "French reading companion with translations, vocab, and scene summaries.",
    "cardDescription": "French reading companion with translations, vocab, and scene summaries.",
    "languages": [
      "Python",
      "JavaScript"
    ],
    "tags": [
      "Full-stack",
      "NLP",
      "Data Engineering",
      "Cloud/Infra",
      "Agentic AI",
      "Concurrency"
    ],
    "coolness": 99,
    "caseStudyRank": 2,
    "showcaseTag": "NLP",
    "showcaseTech": "Cloud Translation",
    "proofPoints": [
      "Scene chunking + LLM summaries for long PDFs",
      "Sentence-level translation + vocabulary extraction",
      "Streaming ingestion API + Next.js reader UI"
    ],
    "overview": "LecteurAide is a French reading companion for long-form PDFs. It chunks content into scenes, generates summaries, overlays sentence-level translation and vocabulary, and adds lightweight quizzes so the reading loop is actually productive.",
    "whatIBuilt": [
      "Back end that chunks PDFs and calls Gemini for scene summaries",
      "Translation + vocabulary layer (sentence-level) using Cloud Translation + NLP prompts",
      "Streaming ingestion API that persists scenes, questions, and glossary entries",
      "Next.js reader UI for scene-by-scene reading, vocab highlighting, and quizzes"
    ],
    "howItWorks": [
      "Upload a French PDF via ingestion API",
      "Chunk into scenes and generate a summary per scene",
      "Compute sentence translations + vocab terms and persist results",
      "Render a reader that layers translations, vocab, and quick checks"
    ],
    "results": [
      "Turns a static PDF into an interactive reading workflow",
      "Designed for long documents and incremental ingestion"
    ],
    "nextSteps": [
      "Add spaced repetition for saved vocabulary",
      "Add offline export for highlights + glossary"
    ],
    "coverImage": {
      "src": "/projects/lecteuraide/lecteur-aide-cover.png",
      "alt": "LecteurAide reading interface"
    },
    "gallery": [],
    "bullets": [
      "Back end chunks French PDFs, calls Gemini for scene summaries, and layers sentence-level translations plus vocab.",
      "Streaming ingestion API uploads books and persists scenes, questions, and glossary terms into SQLite/Postgres.",
      "Next.js reader surfaces scene-by-scene translations, highlighted vocabulary, and comprehension quizzes."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/LecteurAide",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "study-buddy",
    "slug": "study-buddy",
    "emoji": "üß†",
    "period": "Updated Sep 2025",
    "startDate": null,
    "endDate": null,
    "updatedAt": "2025-09-01",
    "stack": [
      "Python",
      "FastAPI",
      "LangChain",
      "CrewAI",
      "ChromaDB"
    ],
    "oneLiner": "Agentic study workflow turning class materials and Anki decks into flashcards and cheat sheets.",
    "cardDescription": "Agentic study workflow that turns notes + decks into flashcards and cheat sheets.",
    "languages": [
      "Python",
      "JavaScript"
    ],
    "tags": [
      "Full-stack",
      "Data Engineering",
      "Agentic AI",
      "Concurrency"
    ],
    "coolness": 94,
    "caseStudyRank": 4,
    "showcaseTag": "Agentic AI",
    "showcaseTech": "CrewAI",
    "proofPoints": [
      "Agents generate flashcards + cheat sheets from raw notes",
      "RAG-backed revisions built from Anki exports",
      "FastAPI + ChromaDB pipeline with simple upload/download UI"
    ],
    "overview": "study-buddy is an agentic workflow for turning class materials into useful outputs: flashcards, cheat sheets, and structured review. It leans on retrieval (ChromaDB) so generations stay anchored in your source material, and it loops Anki exports back in to guide revisions.",
    "whatIBuilt": [
      "CrewAI agent pipeline to expand notes and draft study artifacts",
      "RAG layer using ChromaDB to keep generations grounded",
      "Two-step workflow that incorporates Anki exports for difficulty-weighted revisions",
      "FastAPI service + minimal UI for uploading material and downloading outputs"
    ],
    "howItWorks": [
      "Upload notes/decks",
      "Index key chunks into ChromaDB",
      "Agents generate flashcards/cheat sheets with retrieval context",
      "Optionally loop Anki exports back in to drive revisions"
    ],
    "results": [
      "Repeatable workflow from messy notes to structured study material"
    ],
    "nextSteps": [
      "Add lightweight evaluation for artifact quality (coverage, correctness, redundancy)",
      "Add an opinionated study plan mode (time-boxed reviews)"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "CrewAI-powered agents ingest notes, expand key concepts, and assemble flashcards plus cheat sheets.",
      "Two-step workflow loops Anki exports back in to build difficulty-weighted revisions with RAG context.",
      "FastAPI + Chroma backend with a focused single-page UI for uploading material and downloading artefacts."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/study-buddy",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "Human Digit Classification",
    "slug": "human-digit-classification",
    "emoji": "üî¢",
    "period": "Jan ‚Äì Mar 2025",
    "startDate": "2025-01-01",
    "endDate": "2025-03-01",
    "updatedAt": "2025-03-01",
    "stack": [
      "Python",
      "JavaScript",
      "HTML",
      "PyTorch",
      "ML"
    ],
    "oneLiner": "Computer-vision pipeline that detects hands, counts digits, and serves a web demo.",
    "featuredDescription": "CV pipeline for hand detection and digit-count classification.",
    "cardDescription": "CV pipeline for hand detection and digit-count classification.",
    "languages": [
      "Python",
      "JavaScript"
    ],
    "tags": [
      "Machine Learning",
      "Computer Vision",
      "Algorithms",
      "Full-stack",
      "Data Engineering"
    ],
    "coolness": 98,
    "caseStudyRank": 3,
    "showcaseTag": "Computer Vision",
    "showcaseTech": "PyTorch",
    "proofPoints": [
      "10,000+ custom-labeled images",
      "Two-stage CNN: bbox regression ‚Üí digit-count classification",
      "Augmentation + evaluation loop to improve robustness"
    ],
    "overview": "This project builds a two-stage computer vision pipeline: detect a hand region and then classify the number of digits being shown. I built the dataset, labeling tooling, and training loop end-to-end, then wired it into a simple web demo.",
    "whatIBuilt": [
      "Two-stage CNN pipeline in PyTorch (bbox regression + digit-count classification)",
      "Custom dataset + home-grown labeling tooling (10,000+ annotated images)",
      "Augmentation pipeline applying transforms to both images and annotations"
    ],
    "howItWorks": [
      "Train a bounding-box regressor with Generalized IoU loss",
      "Crop and standardize the detected hand region",
      "Run a digit-count classifier on the cropped region",
      "Iterate via evaluation + targeted augmentation"
    ],
    "results": [
      "Improved F1 through iterative evaluation and augmentation"
    ],
    "nextSteps": [
      "Try modern detector backbones (YOLO-style) for robustness",
      "Add clearer demo outputs (confidence, failure modes)"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "Built a two-stage CNN pipeline in PyTorch: bounding-box regression with Generalized IoU loss ‚Üí digit-count classification; improved F1-score through iterative evaluation.",
      "Created a custom, fully annotated dataset of 10,000+ images from scratch using home-grown labeling tools.",
      "Applied image + annotation transformations for data augmentation and robustness."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/Human-Digit-Recognition",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "Counterfactual Regret Exploration (CFR-Min)",
    "slug": "cfr-exploration",
    "emoji": "‚ôüÔ∏è",
    "period": "Nov 2024 ‚Äì Present",
    "startDate": "2024-11-01",
    "endDate": null,
    "updatedAt": null,
    "stack": [
      "Jupyter",
      "NumPy",
      "Reinforcement Learning"
    ],
    "oneLiner": "Research notebooks applying CFR-Min techniques to imperfect-information strategy games.",
    "cardDescription": "CFR-Min research notebooks exploring equilibria in imperfect-information games.",
    "languages": [
      "Python"
    ],
    "tags": [
      "Game Theory",
      "Algorithms",
      "Machine Learning"
    ],
    "coolness": 86,
    "showcaseTag": "Game Theory",
    "showcaseTech": "NumPy",
    "proofPoints": [
      "CFR-Min notebooks for imperfect-information games",
      "Worked examples: Kuhn Poker, Colonel Blotto",
      "Exploration toward general sequential games"
    ],
    "overview": "A set of research notebooks exploring CFR-Min for finding equilibria in imperfect-information settings. The focus is on building intuition through worked examples and gradually generalizing toward more complex sequential games.",
    "whatIBuilt": [
      "Notebooks implementing and experimenting with CFR-Min ideas",
      "Worked examples for small games (Kuhn Poker, Colonel Blotto)",
      "A playground to test abstractions and convergence behavior"
    ],
    "howItWorks": [
      "Define game representation and information sets",
      "Run CFR-Min iterations to update regrets/strategies",
      "Track convergence signals and compare variants",
      "Extend to additional worked examples as the framework stabilizes"
    ],
    "results": [],
    "nextSteps": [
      "Add more consistent experiment logging and plots",
      "Extend toward larger sequential games with abstractions"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "Exploring CFR-Min for Nash equilibria in imperfect-information games.",
      "Worked examples: Colonel Blotto, Kuhn Poker.",
      "Toward general application for sequential games (Risk, Poker)."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/CFR-Exploration",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "No-Limit Hold‚Äôem Alpha-Beta Pruning",
    "slug": "nlhe-alpha-beta",
    "emoji": "üÉè",
    "period": "Aug ‚Äì Dec 2024",
    "startDate": "2024-08-01",
    "endDate": "2024-12-01",
    "updatedAt": "2024-12-01",
    "stack": [
      "Python",
      "NumPy",
      "Monte Carlo"
    ],
    "oneLiner": "Alpha-beta search experiments for simplified No-Limit Hold‚Äôem decision trees.",
    "cardDescription": "Alpha‚Äìbeta + Monte Carlo approximations for simplified Hold‚Äôem decision trees.",
    "languages": [
      "Python"
    ],
    "tags": [
      "Game Theory",
      "Algorithms"
    ],
    "coolness": 96,
    "showcaseTag": "Game Theory",
    "showcaseTech": "Monte Carlo",
    "proofPoints": [
      "2+ orders of magnitude complexity reduction via alpha‚Äìbeta pruning",
      "Reduced game space to < 1e-6 using abstractions + rollouts",
      "Decision-tree exploration for simplified NLHE"
    ],
    "overview": "This project explores adversarial search for simplified no-limit Hold‚Äôem decision trees. The emphasis is on computational tractability: reduce branching aggressively with alpha‚Äìbeta pruning and abstractions, then use Monte Carlo rollouts to approximate the remaining space.",
    "whatIBuilt": [
      "Alpha‚Äìbeta pruning over simplified NLHE decision trees",
      "Monte Carlo rollouts for approximating outcomes in large spaces",
      "State/action abstractions (bucketing, action limiting, range modeling)"
    ],
    "howItWorks": [
      "Represent NLHE states with simplified assumptions",
      "Use alpha‚Äìbeta pruning to cut branches early",
      "Approximate remaining leaf outcomes via Monte Carlo rollouts",
      "Evaluate search behavior and tune abstractions"
    ],
    "results": [
      "Reduced computational complexity by 2+ orders of magnitude in early-game positions",
      "Reduced game space to < 1e-6 of the original via abstractions and rollouts"
    ],
    "nextSteps": [
      "Explore stronger abstractions for ranges and bet sizing",
      "Benchmark against alternative search variants"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "Employed adversarial search with alpha‚Äìbeta pruning to navigate simplified no-limit Hold‚Äôem decision trees, reducing computational complexity by 2+ orders of magnitude in early-game positions.",
      "Reduced the game space to < 1e-6 of the original via Monte Carlo rollouts, hand bucketing, action limiting, and a probabilistic hand-range model (complete-information approximation)."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/PokerML",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "Maze-Game",
    "slug": "maze-game",
    "emoji": "üåÄ",
    "period": "Updated Feb 2025",
    "startDate": null,
    "endDate": null,
    "updatedAt": "2025-02-01",
    "stack": [
      "Java",
      "javalib.impworld",
      "javalib.worldimages"
    ],
    "oneLiner": "Interactive maze generator and solver with DFS/BFS playback and player mode in Java.",
    "cardDescription": "Java maze generator/solver with BFS/DFS playback and an interactive player mode.",
    "languages": [
      "Java"
    ],
    "tags": [
      "Algorithms"
    ],
    "coolness": 83,
    "showcaseTag": "Algorithms",
    "showcaseTech": "Java",
    "proofPoints": [
      "Maze generation with guaranteed solvability",
      "BFS/DFS solver visualization + playback",
      "Interactive player mode with controls + collision"
    ],
    "overview": "A Java maze generator and solver with multiple modes: generate mazes, watch BFS/DFS solve them, or play through manually. Built to make pathfinding mechanics tangible instead of abstract.",
    "whatIBuilt": [
      "Maze generator with adjustable difficulty/layout",
      "BFS/DFS solver overlays and playback visualization",
      "Interactive mode with keyboard controls and collision handling"
    ],
    "howItWorks": [
      "Generate a maze with a chosen layout/difficulty",
      "Run BFS/DFS to compute a path",
      "Render solver overlays to visualize the algorithm‚Äôs progress",
      "Optionally play through the maze in manual mode"
    ],
    "results": [],
    "nextSteps": [
      "Add more maze generation variants and heuristics",
      "Add performance metrics for solver comparisons"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "Generates solvable mazes with adjustable difficulty and layouts.",
      "Interactive run mode with keyboard controls and collision handling.",
      "Includes visual solver overlays to demonstrate path-finding tactics."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/Maze-Game",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "NQueensGeneticAlgorithms",
    "slug": "nqueens-genetic-algorithms",
    "emoji": "‚ôõ",
    "period": "Updated Feb 2025",
    "startDate": null,
    "endDate": null,
    "updatedAt": "2025-02-01",
    "stack": [
      "Python",
      "Genetic Algorithms"
    ],
    "oneLiner": "Genetic algorithm playground evolving conflict-free N-Queens boards.",
    "cardDescription": "Genetic algorithm playground evolving conflict-free N-Queens boards.",
    "languages": [
      "Python"
    ],
    "tags": [
      "Algorithms"
    ],
    "coolness": 84,
    "showcaseTag": "Algorithms",
    "showcaseTech": "Genetic Algorithms",
    "proofPoints": [
      "Tournament selection + crossover toward zero conflicts",
      "Adaptive mutation rate by board size",
      "CLI/.env configurable experiments"
    ],
    "overview": "A genetic algorithm playground for evolving conflict-free N-Queens boards. The focus is on experimenting with selection, crossover, mutation schedules, and configuration knobs to see how convergence changes.",
    "whatIBuilt": [
      "Genetic search with tournament selection and single-point crossover",
      "Mutation schedule that scales with board size",
      "CLI + .env configuration for quick experimentation"
    ],
    "howItWorks": [
      "Initialize a population of candidate boards",
      "Score fitness based on queen conflicts",
      "Select parents and apply crossover + mutation",
      "Iterate until convergence or iteration cap"
    ],
    "results": [],
    "nextSteps": [
      "Add clearer run logs/plots to compare parameter settings",
      "Try alternate encodings for board representation"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "Tournament selection and single-point crossover push populations toward zero-collision layouts.",
      "Mutation rate scales automatically with board size for balanced exploration and convergence.",
      ".env-configurable constants let you trial different populations, iteration caps, and board sizes from the CLI."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/NQueensGeneticAlgorithms",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "Hex Reversi",
    "slug": "hex-reversi",
    "emoji": "üî∑",
    "period": "Updated 2025",
    "startDate": null,
    "endDate": null,
    "updatedAt": "2025-01-01",
    "stack": [
      "Java",
      "Swing"
    ],
    "oneLiner": "Extensible hex-grid Reversi with GUI, modular strategies, and adapter support.",
    "cardDescription": "Hex-grid Reversi with GUI, MVC architecture, and pluggable strategies.",
    "languages": [
      "Java"
    ],
    "tags": [
      "Algorithms",
      "Game Theory"
    ],
    "coolness": 87,
    "showcaseTag": "Game Theory",
    "showcaseTech": "Swing",
    "proofPoints": [
      "Hex-grid Reversi engine with configurable board shapes",
      "MVC architecture with pluggable views/controllers",
      "Composable AI strategies (minimax + heuristics)"
    ],
    "overview": "Hex Reversi is an extensible Reversi/Othello implementation on a hexagonal grid. The core emphasis is software design: clean MVC separation, adapters for different play modes, and modular AI strategies that can be mixed and matched.",
    "whatIBuilt": [
      "Hex-grid Reversi engine with configurable board shapes and starting states",
      "MVC architecture with GUI + text views and a controller layer",
      "Strategy system including minimax and composable heuristics"
    ],
    "howItWorks": [
      "Represent the board on an odd-r hex coordinate system",
      "Validate moves and apply flips according to Reversi rules",
      "Run players (human/AI) through a controller loop",
      "Plug different strategies into the AI player"
    ],
    "results": [],
    "nextSteps": [
      "Add stronger evaluation heuristics and time controls",
      "Improve UI polish and strategy visualization"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "Reversi on a hexagonal odd-r grid with configurable board shapes and starting states.",
      "Extensible MVC design: model interfaces, pluggable text/GUI views, and a controller to orchestrate play.",
      "Factory creator builds variants without exposing constructors; supports multiple player types (human/AI).",
      "Modular strategies (minimax, capture-max, corners, avoid-near-corners) with combinators to compose heuristics."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/Hex-Reversi",
        "kind": "repo"
      }
    ]
  },
  {
    "title": "Linux Shell (C)",
    "slug": "linux-shell-c",
    "emoji": "üêö",
    "period": "Oct 2024",
    "startDate": "2024-10-01",
    "endDate": "2024-10-01",
    "updatedAt": "2024-10-01",
    "stack": [
      "C",
      "Concurrency",
      "Data Structures"
    ],
    "oneLiner": "Custom C shell with pipelines, signal handling, and a suite of built-in commands.",
    "cardDescription": "Custom C shell supporting pipelines, redirection, signals, and built-in commands.",
    "languages": [
      "C"
    ],
    "tags": [
      "Concurrency",
      "Algorithms"
    ],
    "coolness": 85,
    "showcaseTag": "Concurrency",
    "showcaseTech": "C",
    "proofPoints": [
      "Pipelines + redirection + signal handling",
      "Built-ins: source, prev, cd, help, verbose",
      "Process orchestration for sequential execution"
    ],
    "overview": "A custom shell written in C with support for command execution, piping, redirection, and signals. The project focuses on process control and correctness under typical shell behaviors.",
    "whatIBuilt": [
      "Command execution with piping and I/O redirection",
      "Signal handling and process orchestration",
      "Built-in commands (source, prev, cd, help, verbose toggle)"
    ],
    "howItWorks": [
      "Parse input into commands and pipeline segments",
      "Fork/exec child processes and wire pipes between them",
      "Apply redirections and handle signals appropriately",
      "Track history for built-ins like prev"
    ],
    "results": [],
    "nextSteps": [
      "Add job control (fg/bg) if desired",
      "Harden parsing for edge cases and quoting rules"
    ],
    "coverImage": null,
    "gallery": [],
    "bullets": [
      "Fully operational shell: commands, piping, I/O redirection, signals.",
      "Child processes for sequential execution.",
      "Custom commands: source, prev, cd, help, verbose toggle."
    ],
    "links": [
      {
        "label": "Git Repo",
        "href": "https://github.com/seanpatrickmay/Linux-Shell",
        "kind": "repo"
      }
    ]
  }
]
